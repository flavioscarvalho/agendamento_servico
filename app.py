# -*- coding: utf-8 -*-
import streamlit as st
import pandas as pd
from datetime import datetime
import sqlalchemy
import bcrypt

# --- Configura√ß√µes da P√°gina ---
st.set_page_config(
    page_title="Sistema de Agendamento",
    page_icon="üìÖ",
    layout="wide"
)

# --- Constantes ---
DISCIPLINAS = ["Matem√°tica", "F√≠sica", "Qu√≠mica", "Portugu√™s", "Ingl√™s", "Hist√≥ria", "Geografia", "Biologia"]
EQUIPAMENTOS = ["Notebook", "Celular", "Tablet", "Projetor", "Caixa de Som"]
HORARIOS = ["1¬∫", "2¬∫", "3¬∫", "4¬∫", "5¬∫", "6¬∫"]
TURNOS = ["Manh√£", "Tarde"]
SALAS = ["205", "206"]

# --- CONFIGURA√á√ïES DE ACESSO ---
CODIGO_CADASTRO = "SESI2024"  # üîë C√≥digo para cadastro
ADMINS = ["admin", "diretor", "coordenador", "secretaria"]  # üë®‚Äçüíº Administradores

# --- STATUS DE AGENDAMENTO ---
STATUS_PENDENTE = "Pendente"
STATUS_APROVADO = "Aprovado"
STATUS_REJEITADO = "Rejeitado"

# Cores para cada status
STATUS_COLORS = {
    STATUS_PENDENTE: "üü°",    # Amarelo
    STATUS_APROVADO: "üü¢",    # Verde
    STATUS_REJEITADO: "üî¥"    # Vermelho
}

# --- Conex√£o com o Banco de Dados ---
@st.cache_resource
def init_connection():
    """Inicializa a conex√£o com o banco de dados com tratamento de erro."""
    try:
        return st.connection("db_agendamentos", type="sql")
    except Exception as e:
        st.error(f"‚ùå Erro ao conectar com o banco de dados. Verifique as configura√ß√µes de secrets.")
        st.error(f"Detalhes t√©cnicos: {str(e)}")
        st.info("üí° Certifique-se de que as credenciais do Supabase est√£o configuradas corretamente no Streamlit Cloud.")
        st.stop()

# --- Fun√ß√µes de Verifica√ß√£o ---
def eh_admin(username):
    """Verifica se o usu√°rio √© administrador"""
    return username in ADMINS

def obter_tipo_usuario(username):
    """Retorna o tipo do usu√°rio para exibi√ß√£o"""
    return "üë®‚Äçüíº Administrador" if eh_admin(username) else "üë©‚Äçüè´ Professor"

def obter_cor_status(status):
    """Retorna a cor/emoji do status"""
    return STATUS_COLORS.get(status, "‚ö™")

# --- Fun√ß√µes do Banco de Dados ---

def verificar_coluna_existe(conn, tabela, coluna):
    """Verifica se uma coluna existe na tabela"""
    try:
        with conn.session as s:
            result = s.execute(sqlalchemy.text(f"""
                SELECT column_name 
                FROM information_schema.columns 
                WHERE table_name = '{tabela}' 
                AND column_name = '{coluna}'
                AND table_schema = 'public'
            """))
            return result.fetchone() is not None
    except:
        return False

def adicionar_coluna_seguro(conn, tabela, coluna, tipo, default=None):
    """Adiciona uma coluna de forma segura, verificando se j√° existe"""
    try:
        if not verificar_coluna_existe(conn, tabela, coluna):
            with conn.session as s:
                if default:
                    # Casos especiais para fun√ß√µes PostgreSQL (sem aspas)
                    if default.upper() in ['CURRENT_TIMESTAMP', 'NOW()', 'CURRENT_DATE']:
                        sql = f'ALTER TABLE {tabela} ADD COLUMN "{coluna}" {tipo} DEFAULT {default}'
                    else:
                        sql = f'ALTER TABLE {tabela} ADD COLUMN "{coluna}" {tipo} DEFAULT \'{default}\''
                else:
                    sql = f'ALTER TABLE {tabela} ADD COLUMN "{coluna}" {tipo}'
                
                s.execute(sqlalchemy.text(sql))
                s.commit()
                st.success(f"‚úÖ Coluna '{coluna}' adicionada com sucesso!")
                return True
        else:
            st.info(f"‚ÑπÔ∏è Coluna '{coluna}' j√° existe.")
            return True
    except Exception as e:
        st.warning(f"‚ö†Ô∏è Problema ao adicionar coluna '{coluna}': {str(e)}")
        
        # Tenta vers√£o mais simples sem DEFAULT
        if default:
            try:
                with conn.session as s:
                    sql = f'ALTER TABLE {tabela} ADD COLUMN "{coluna}" {tipo}'
                    s.execute(sqlalchemy.text(sql))
                    s.commit()
                    st.info(f"‚úÖ Coluna '{coluna}' adicionada sem valor padr√£o.")
                    return True
            except Exception as e2:
                st.error(f"‚ùå Erro final ao adicionar coluna '{coluna}': {str(e2)}")
        
        return False

def inicializar_banco():
    """Cria as tabelas no banco de dados se elas n√£o existirem."""
    try:
        conn = init_connection()
        
        # Verifica se as tabelas j√° existem
        with conn.session as s:
            result = s.execute(sqlalchemy.text("""
                SELECT table_name 
                FROM information_schema.tables 
                WHERE table_schema = 'public' 
                AND table_name IN ('usuarios', 'agendamentos')
            """))
            existing_tables = [row[0] for row in result.fetchall()]
            
            # Cria tabela usuarios se n√£o existir
            if 'usuarios' not in existing_tables:
                s.execute(sqlalchemy.text('''
                    CREATE TABLE usuarios (
                        id SERIAL PRIMARY KEY,
                        username TEXT UNIQUE NOT NULL,
                        password_hash TEXT NOT NULL,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                    );
                '''))
                s.commit()
                st.success("‚úÖ Tabela 'usuarios' criada com sucesso!")
                
            # Cria tabela agendamentos se n√£o existir
            if 'agendamentos' not in existing_tables:
                s.execute(sqlalchemy.text('''
                    CREATE TABLE agendamentos (
                        id SERIAL PRIMARY KEY,
                        "Data" DATE NOT NULL,
                        "Disciplina" TEXT,
                        "Equipamentos" TEXT,
                        "Horario" TEXT,
                        "Turno" TEXT,
                        "Sala" TEXT,
                        "Professor" TEXT,
                        "Status" TEXT DEFAULT 'Pendente',
                        "Observacoes" TEXT,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                    );
                '''))
                s.commit()
                st.success("‚úÖ Tabela 'agendamentos' criada com sucesso!")
            # else:
            #     # Tabela existe, verificar se precisa adicionar novas colunas
            #     st.info("‚ÑπÔ∏è Verificando estrutura da tabela agendamentos...")
                
            #     # Adiciona colunas uma por vez de forma segura
            #     adicionar_coluna_seguro(conn, 'agendamentos', 'Status', 'TEXT', 'Pendente')
            #     adicionar_coluna_seguro(conn, 'agendamentos', 'Observacoes', 'TEXT')
            #     # updated_at removido - n√£o √© necess√°rio para funcionamento
                
            #     # Atualiza registros antigos que n√£o t√™m status
            #     try:
            #         with conn.session as s:
            #             s.execute(sqlalchemy.text("""
            #                 UPDATE agendamentos 
            #                 SET "Status" = 'Pendente' 
            #                 WHERE "Status" IS NULL
            #             """))
            #             s.commit()
            #             st.info("‚ÑπÔ∏è Registros antigos atualizados com status padr√£o.")
            #     except Exception as e:
            #         st.warning(f"‚ö†Ô∏è Aviso ao atualizar registros: {str(e)}")
            
        return conn
            
    except Exception as e:
        st.error(f"‚ùå Erro ao inicializar banco de dados: {str(e)}")
        
        # Tenta recuperar mostrando op√ß√£o de reset
        st.error("üîß **Problema detectado na estrutura do banco!**")
        
        if st.button("üîÑ Tentar Resetar Estrutura"):
            try:
                conn = init_connection()
                with conn.session as s:
                    # Remove tabela problem√°tica e recria
                    s.execute(sqlalchemy.text("DROP TABLE IF EXISTS agendamentos_backup"))
                    s.execute(sqlalchemy.text("""
                        CREATE TABLE agendamentos_backup AS 
                        SELECT * FROM agendamentos
                    """))
                    s.execute(sqlalchemy.text("DROP TABLE agendamentos"))
                    s.execute(sqlalchemy.text('''
                        CREATE TABLE agendamentos (
                            id SERIAL PRIMARY KEY,
                            "Data" DATE NOT NULL,
                            "Disciplina" TEXT,
                            "Equipamentos" TEXT,
                            "Horario" TEXT,
                            "Turno" TEXT,
                            "Sala" TEXT,
                            "Professor" TEXT,
                            "Status" TEXT DEFAULT 'Pendente',
                            "Observacoes" TEXT,
                            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                        );
                    '''))
                    
                    # Restaura dados
                    s.execute(sqlalchemy.text("""
                        INSERT INTO agendamentos 
                        ("Data", "Disciplina", "Equipamentos", "Horario", "Turno", "Sala", "Professor", created_at)
                        SELECT "Data", "Disciplina", "Equipamentos", "Horario", "Turno", "Sala", "Professor", created_at
                        FROM agendamentos_backup
                    """))
                    
                    s.execute(sqlalchemy.text("DROP TABLE agendamentos_backup"))
                    s.commit()
                    
                st.success("‚úÖ Estrutura resetada com sucesso!")
                st.rerun()
                
            except Exception as reset_error:
                st.error(f"‚ùå Erro no reset: {str(reset_error)}")
        
        st.stop()

def hash_password(password):
    """Cria um hash seguro para a senha."""
    return bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt())

def verify_password(stored_hash, provided_password):
    """Verifica se a senha fornecida corresponde ao hash armazenado."""
    try:
        return bcrypt.checkpw(provided_password.encode('utf-8'), stored_hash.encode('utf-8'))
    except Exception as e:
        st.error(f"Erro na verifica√ß√£o de senha: {str(e)}")
        return False

def adicionar_usuario(username, password):
    """Adiciona um novo usu√°rio ao banco de dados."""
    try:
        password_hash = hash_password(password)
        conn = init_connection()
        with conn.session as s:
            result = s.execute(sqlalchemy.text("SELECT * FROM usuarios WHERE username = :user"), {'user': username}).first()
            if result:
                return False
            
            s.execute(
                sqlalchemy.text("INSERT INTO usuarios (username, password_hash) VALUES (:user, :phash)"),
                {'user': username, 'phash': password_hash.decode('utf-8')}
            )
            s.commit()
        return True
    except Exception as e:
        st.error(f"Erro ao adicionar usu√°rio: {str(e)}")
        return False

def buscar_usuario(username):
    """Busca um usu√°rio pelo nome."""
    try:
        conn = init_connection()
        with conn.session as s:
            result = s.execute(sqlalchemy.text("SELECT * FROM usuarios WHERE username = :user"), {'user': username}).first()
            return result
    except Exception as e:
        st.error(f"Erro ao buscar usu√°rio: {str(e)}")
        return None

def salvar_agendamento(data, disciplina, equipamentos, horario, turno, sala, professor):
    """Salva um novo agendamento no banco de dados com status pendente."""
    try:
        equipamentos_str = ", ".join(equipamentos)
        conn = init_connection()
        with conn.session as s:
            # Verifica se a coluna Status existe antes de us√°-la
            if verificar_coluna_existe(conn, 'agendamentos', 'Status'):
                s.execute(
                    sqlalchemy.text('''INSERT INTO agendamentos 
                        ("Data", "Disciplina", "Equipamentos", "Horario", "Turno", "Sala", "Professor", "Status") 
                        VALUES (:data, :disc, :equip, :hor, :turno, :sala, :prof, :status)'''),
                    params=dict(data=data, disc=disciplina, equip=equipamentos_str, 
                              hor=horario, turno=turno, sala=sala, prof=professor, status=STATUS_PENDENTE)
                )
            else:
                # Fallback para tabelas antigas
                s.execute(
                    sqlalchemy.text('''INSERT INTO agendamentos 
                        ("Data", "Disciplina", "Equipamentos", "Horario", "Turno", "Sala", "Professor") 
                        VALUES (:data, :disc, :equip, :hor, :turno, :sala, :prof)'''),
                    params=dict(data=data, disc=disciplina, equip=equipamentos_str, 
                              hor=horario, turno=turno, sala=sala, prof=professor)
                )
            s.commit()
        return True
    except Exception as e:
        st.error(f"Erro ao salvar agendamento: {str(e)}")
        return False

def atualizar_status_agendamento(agendamento_id, novo_status, observacoes=""):
    """Atualiza o status de um agendamento."""
    try:
        conn = init_connection()
        with conn.session as s:
            # Verifica se as colunas existem
            if verificar_coluna_existe(conn, 'agendamentos', 'Status'):
                if verificar_coluna_existe(conn, 'agendamentos', 'Observacoes'):
                    s.execute(
                        sqlalchemy.text('''UPDATE agendamentos 
                            SET "Status" = :status, "Observacoes" = :obs
                            WHERE id = :id'''),
                        {'status': novo_status, 'obs': observacoes, 'id': agendamento_id}
                    )
                else:
                    s.execute(
                        sqlalchemy.text('''UPDATE agendamentos 
                            SET "Status" = :status
                            WHERE id = :id'''),
                        {'status': novo_status, 'id': agendamento_id}
                    )
                s.commit()
                return True
            else:
                st.error("‚ùå Tabela n√£o possui coluna de Status. Execute a migra√ß√£o primeiro.")
                return False
    except Exception as e:
        st.error(f"Erro ao atualizar status: {str(e)}")
        return False

def carregar_dados(filtro_status=None, professor=None):
    """Carrega agendamentos do banco de dados com filtros opcionais."""
    try:
        conn = init_connection()
        
        # Verifica se a coluna Status existe
        tem_status = verificar_coluna_existe(conn, 'agendamentos', 'Status')
        
        if tem_status:
            query = 'SELECT * FROM agendamentos WHERE 1=1'
            params = {}
            
            if filtro_status:
                query += ' AND "Status" = :status'
                params['status'] = filtro_status
                
            if professor:
                query += ' AND "Professor" = :professor'
                params['professor'] = professor
                
            query += ' ORDER BY "Data" DESC, created_at DESC'
            
            if params:
                df = conn.query(query, params=params)
            else:
                df = conn.query(query)
        else:
            # Fallback para tabelas antigas sem Status
            query = 'SELECT *, \'Pendente\' as "Status" FROM agendamentos WHERE 1=1'
            
            if professor:
                query += ' AND "Professor" = :professor'
                df = conn.query(query, params={'professor': professor})
            else:
                df = conn.query(query)
                
            query += ' ORDER BY "Data" DESC, created_at DESC'
            
        return df
    except Exception as e:
        st.error(f"Erro ao carregar dados: {str(e)}")
        return pd.DataFrame()

def contar_agendamentos_por_status():
    """Conta agendamentos por status para estat√≠sticas."""
    try:
        conn = init_connection()
        
        if verificar_coluna_existe(conn, 'agendamentos', 'Status'):
            with conn.session as s:
                result = s.execute(sqlalchemy.text('SELECT "Status", COUNT(*) FROM agendamentos GROUP BY "Status"'))
                contadores = dict(result.fetchall())
                
                return {
                    STATUS_PENDENTE: contadores.get(STATUS_PENDENTE, 0),
                    STATUS_APROVADO: contadores.get(STATUS_APROVADO, 0),
                    STATUS_REJEITADO: contadores.get(STATUS_REJEITADO, 0)
                }
        else:
            # Para tabelas antigas, considera tudo como pendente
            with conn.session as s:
                result = s.execute(sqlalchemy.text('SELECT COUNT(*) FROM agendamentos'))
                total = result.fetchone()[0]
                return {STATUS_PENDENTE: total, STATUS_APROVADO: 0, STATUS_REJEITADO: 0}
    except:
        return {STATUS_PENDENTE: 0, STATUS_APROVADO: 0, STATUS_REJEITADO: 0}

# --- Telas da Aplica√ß√£o ---

def tela_professor():
    st.header(f"üìÖ Agendamento de Recursos - Bem-vindo(a), {st.session_state.username}!")
    
    # Verifica se o sistema tem recurso de aprova√ß√£o
    conn = init_connection()
    tem_sistema_aprovacao = verificar_coluna_existe(conn, 'agendamentos', 'Status')
    
    if tem_sistema_aprovacao:
        st.markdown("Utilize o formul√°rio abaixo para solicitar o uso de equipamentos e salas.")
    else:
        st.markdown("Utilize o formul√°rio abaixo para agendar o uso de equipamentos e salas.")
        st.info("‚ÑπÔ∏è Sistema em modo b√°sico. Para ativar aprova√ß√µes, execute a migra√ß√£o do banco.")

    with st.form("form_agendamento", clear_on_submit=True):
        if tem_sistema_aprovacao:
            st.subheader("üìù Nova Solicita√ß√£o de Agendamento")
        else:
            st.subheader("üìù Novo Agendamento")
            
        col1, col2 = st.columns(2)
        with col1:
            data_selecionada = st.date_input("üóìÔ∏è Selecione o Dia", min_value=datetime.today())
            disciplina = st.selectbox("üìö Disciplina", options=DISCIPLINAS)
            equipamentos = st.multiselect("üíª Equipamentos", options=EQUIPAMENTOS)
        with col2:
            horario = st.selectbox("‚è∞ Hor√°rio", options=HORARIOS)
            turno = st.selectbox("‚òÄÔ∏è Turno", options=TURNOS)
            sala = st.selectbox("üö™ Sala", options=SALAS)
        
        botao_texto = "üì§ Enviar Solicita√ß√£o" if tem_sistema_aprovacao else "‚úÖ Salvar Agendamento"
        
        if st.form_submit_button(botao_texto):
            if not equipamentos:
                st.warning("‚ö†Ô∏è Por favor, selecione pelo menos um equipamento.")
            else:
                if salvar_agendamento(data_selecionada, disciplina, equipamentos, horario, turno, sala, st.session_state.username):
                    if tem_sistema_aprovacao:
                        st.success(f"‚úÖ Solicita√ß√£o enviada! Aguarde aprova√ß√£o do administrador.")
                        st.info("üí° Voc√™ pode acompanhar o status da sua solicita√ß√£o abaixo.")
                    else:
                        st.success(f"‚úÖ Agendamento para a sala {sala} no dia {data_selecionada.strftime('%d/%m/%Y')} salvo com sucesso!")

    st.markdown("---")
    
    if tem_sistema_aprovacao:
        st.subheader("üìã Minhas Solicita√ß√µes de Agendamento")
        
        # Filtros para o professor
        col1, col2 = st.columns(2)
        with col1:
            filtro_status = st.selectbox(
                "üéØ Filtrar por Status:",
                options=["Todos", STATUS_PENDENTE, STATUS_APROVADO, STATUS_REJEITADO],
                key="professor_filtro"
            )
        
        # Carrega dados do professor
        if filtro_status == "Todos":
            df = carregar_dados(professor=st.session_state.username)
        else:
            df = carregar_dados(filtro_status=filtro_status, professor=st.session_state.username)
        
        if not df.empty:
            # Adiciona coluna com cor do status
            df_display = df.copy()
            if 'Status' in df_display.columns:
                df_display['Status_Display'] = df_display['Status'].apply(
                    lambda x: f"{obter_cor_status(x)} {x}"
                )
                
                # Estat√≠sticas r√°pidas
                stats = df['Status'].value_counts()
                col1, col2, col3 = st.columns(3)
                with col1:
                    st.metric("üü° Pendentes", stats.get(STATUS_PENDENTE, 0))
                with col2:
                    st.metric("üü¢ Aprovados", stats.get(STATUS_APROVADO, 0))
                with col3:
                    st.metric("üî¥ Rejeitados", stats.get(STATUS_REJEITADO, 0))
                
                # Reorganiza colunas para melhor visualiza√ß√£o
                colunas_ordem = ['Data', 'Disciplina', 'Equipamentos', 'Horario', 'Turno', 'Sala', 'Status_Display']
                if 'Observacoes' in df_display.columns:
                    colunas_ordem.append('Observacoes')
                    
                df_display = df_display[colunas_ordem]
                df_display = df_display.rename(columns={'Status_Display': 'Status'})
                
                # Alertas baseados no status
                pendentes = stats.get(STATUS_PENDENTE, 0)
                if pendentes > 0:
                    st.info(f"‚è≥ Voc√™ tem {pendentes} solicita√ß√£o(√µes) aguardando aprova√ß√£o.")
                    
            st.dataframe(df_display, use_container_width=True)
        else:
            st.info("‚ÑπÔ∏è Voc√™ ainda n√£o possui solicita√ß√µes de agendamento.")
    else:
        st.subheader("üìã Meus Agendamentos")
        df = carregar_dados(professor=st.session_state.username)
        if not df.empty:
            st.dataframe(df, use_container_width=True)
        else:
            st.info("‚ÑπÔ∏è Voc√™ ainda n√£o possui agendamentos.")

def tela_admin():
    st.header("üîë Painel Administrativo")
    
    # Verifica se o sistema tem recurso de aprova√ß√£o
    conn = init_connection()
    tem_sistema_aprovacao = verificar_coluna_existe(conn, 'agendamentos', 'Status')
    
    if tem_sistema_aprovacao:
        st.markdown("Gerencie todas as solicita√ß√µes de agendamento do sistema.")
        
        # Estat√≠sticas gerais
        stats = contar_agendamentos_por_status()
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            st.metric("üìä Total", sum(stats.values()))
        with col2:
            st.metric("üü° Pendentes", stats[STATUS_PENDENTE])
        with col3:
            st.metric("üü¢ Aprovados", stats[STATUS_APROVADO])
        with col4:
            st.metric("üî¥ Rejeitados", stats[STATUS_REJEITADO])

        # Filtros administrativos
        st.subheader("üîç Filtros e A√ß√µes")
        col1, col2 = st.columns(2)
        
        with col1:
            filtro_status_admin = st.selectbox(
                "üéØ Filtrar por Status:",
                options=["Todos", STATUS_PENDENTE, STATUS_APROVADO, STATUS_REJEITADO],
                key="admin_filtro"
            )
        
        with col2:
            if stats[STATUS_PENDENTE] > 0:
                st.warning(f"‚ö†Ô∏è {stats[STATUS_PENDENTE]} solicita√ß√£o(√µes) aguardando sua aprova√ß√£o!")

        # Carrega e exibe dados
        if filtro_status_admin == "Todos":
            df = carregar_dados()
        else:
            df = carregar_dados(filtro_status=filtro_status_admin)

        if df.empty:
            st.info("‚ÑπÔ∏è Nenhuma solicita√ß√£o encontrada com os filtros selecionados.")
            return

        st.subheader(f"üìã Solicita√ß√µes de Agendamento - {filtro_status_admin}")
        
        # Interface de aprova√ß√£o para itens pendentes
        if filtro_status_admin in ["Todos", STATUS_PENDENTE]:
            df_pendentes = df[df['Status'] == STATUS_PENDENTE] if filtro_status_admin == "Todos" else df
            
            if not df_pendentes.empty:
                st.markdown("### ‚ö° A√ß√µes R√°pidas - Pendentes")
                
                for idx, row in df_pendentes.iterrows():
                    with st.container():
                        col1, col2, col3, col4, col5 = st.columns([2, 1, 1, 1, 1])
                        
                        with col1:
                            st.write(f"**{row['Professor']}** - {row['Data']} - {row['Disciplina']}")
                            st.write(f"üö™ Sala {row['Sala']} | ‚è∞ {row['Horario']} ({row['Turno']}) | üíª {row['Equipamentos']}")
                        
                        with col2:
                            st.write("üü° Pendente")
                        
                        with col3:
                            if st.button("‚úÖ Aprovar", key=f"aprovar_{row['id']}"):
                                if atualizar_status_agendamento(row['id'], STATUS_APROVADO):
                                    st.success("Aprovado!")
                                    st.rerun()
                        
                        with col4:
                            if st.button("‚ùå Rejeitar", key=f"rejeitar_{row['id']}"):
                                if atualizar_status_agendamento(row['id'], STATUS_REJEITADO):
                                    st.success("Rejeitado!")
                                    st.rerun()
                        
                        with col5:
                            if verificar_coluna_existe(conn, 'agendamentos', 'Observacoes'):
                                with st.popover("üìù Obs"):
                                    obs = st.text_area("Observa√ß√µes:", key=f"obs_{row['id']}", height=100)
                                    if st.button("üíæ Salvar", key=f"salvar_obs_{row['id']}"):
                                        if atualizar_status_agendamento(row['id'], row['Status'], obs):
                                            st.success("Salvo!")
                        
                        st.divider()

        # Tabela completa
        st.markdown("### üìä Visualiza√ß√£o Completa")
        
        # Prepara dados para exibi√ß√£o
        df_display = df.copy()
        if 'Status' in df_display.columns:
            df_display['Status_Display'] = df_display['Status'].apply(
                lambda x: f"{obter_cor_status(x)} {x}"
            )
            
            # Reorganiza colunas
            colunas_ordem = ['Data', 'Professor', 'Disciplina', 'Equipamentos', 'Horario', 'Turno', 'Sala', 'Status_Display']
            if 'Observacoes' in df_display.columns:
                colunas_ordem.append('Observacoes')
                
            df_display = df_display[colunas_ordem]
            df_display = df_display.rename(columns={'Status_Display': 'Status'})
        
        st.dataframe(df_display, use_container_width=True)
        
    else:
        st.markdown("Visualize todos os agendamentos realizados no sistema.")
        st.warning("‚ö†Ô∏è Sistema em modo b√°sico. Execute a migra√ß√£o para ativar o sistema de aprova√ß√£o.")
        
        df = carregar_dados()
        if df.empty:
            st.info("‚ÑπÔ∏è Nenhum agendamento foi realizado ainda.")
        else:
            st.dataframe(df, use_container_width=True)

def tela_login():
    st.sidebar.image("https://images.unsplash.com/photo-1517245386807-bb43f82c33c4?q=80&w=2070&auto=format&fit=crop", use_container_width=True)
    st.sidebar.title("üîê Login do Sistema")

    tab_login, tab_register = st.sidebar.tabs(["üîë Login", "üìù Registrar-se"])

    with tab_login:
        username = st.text_input("üë§ Usu√°rio", key="login_user").lower().strip()
        password = st.text_input("üîë Senha", type="password", key="login_pass")
        if st.button("üöÄ Entrar"):
            if not username or not password:
                st.error("‚ùå Por favor, preencha todos os campos.")
            else:
                user_data = buscar_usuario(username)
                if user_data and verify_password(user_data.password_hash, password):
                    st.session_state.logged_in = True
                    st.session_state.username = user_data.username
                    st.success(f"‚úÖ Login realizado como {obter_tipo_usuario(username)}!")
                    st.rerun()
                else:
                    st.error("‚ùå Usu√°rio ou senha inv√°lidos.")

    with tab_register:
        st.markdown("### üîë Cadastro Restrito")
        
        st.info(f"""
        üí° **Como se cadastrar:**
        
        üîë **C√≥digo necess√°rio:** `{CODIGO_CADASTRO}`
        
        **üë®‚Äçüíº Para ser ADMINISTRADOR:**
        Use um destes usernames: {', '.join(ADMINS)}
        
        **üë©‚Äçüè´ Para ser PROFESSOR:**
        Use qualquer outro username (ex: joao.silva, maria.santos)
        """)
        
        codigo_acesso = st.text_input("üîë C√≥digo de Acesso")
        new_username = st.text_input("üë§ Novo Usu√°rio", key="reg_user").lower().strip()
        new_password = st.text_input("üîë Nova Senha", type="password", key="reg_pass")
        
        if new_username:
            tipo_previsto = obter_tipo_usuario(new_username)
            if eh_admin(new_username):
                st.success(f"‚úÖ Ser√° cadastrado como: {tipo_previsto}")
            else:
                st.info(f"‚ÑπÔ∏è Ser√° cadastrado como: {tipo_previsto}")
        
        if st.button("üìù Registrar"):
            if not codigo_acesso:
                st.error("‚ùå Digite o c√≥digo de acesso!")
            elif codigo_acesso != CODIGO_CADASTRO:
                st.error("‚ùå C√≥digo de acesso inv√°lido!")
            elif not new_username or not new_password:
                st.warning("‚ö†Ô∏è Por favor, preencha todos os campos.")
            elif len(new_password) < 4:
                st.warning("‚ö†Ô∏è A senha deve ter pelo menos 4 caracteres.")
            else:
                if adicionar_usuario(new_username, new_password):
                    tipo_usuario = obter_tipo_usuario(new_username)
                    st.success(f"‚úÖ Usu√°rio registrado como {tipo_usuario}!")
                    st.balloons()
                else:
                    st.error("‚ùå Este nome de usu√°rio j√° existe.")
    
    if not st.session_state.get('logged_in', False):
        st.title("üéì Sistema de Agendamento com Aprova√ß√£o")
        st.markdown("### üìö Sistema profissional para gest√£o de recursos educacionais")
        
        # Verifica se tem sistema de aprova√ß√£o
        try:
            conn = init_connection()
            tem_aprovacao = verificar_coluna_existe(conn, 'agendamentos', 'Status')
            
            if tem_aprovacao:
                st.success("üÜï **Sistema com Aprova√ß√£o de Agendamentos Ativo!**")
            else:
                st.info("‚ÑπÔ∏è Sistema em modo b√°sico. Execute a migra√ß√£o para ativar aprova√ß√µes.")
        except:
            pass
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.image("https://images.unsplash.com/photo-1522202176988-66273c2fd55f?q=80&w=2071&auto=format&fit=crop", caption="Gest√£o profissional de recursos")
            
        with col2:
            st.markdown("""
            ### üöÄ Funcionalidades do Sistema:
            
            **üë©‚Äçüè´ Para Professores:**
            - üì§ Enviar solicita√ß√µes de agendamento
            - üëÄ Acompanhar status das solicita√ß√µes
            - üü° Ver pendentes | üü¢ Aprovados | üî¥ Rejeitados
            
            **üë®‚Äçüíº Para Administradores:**
            - ‚úÖ Aprovar/rejeitar solicita√ß√µes
            - üìä Visualizar estat√≠sticas completas
            - üìù Adicionar observa√ß√µes aos agendamentos
            - üîç Filtrar por status e professor
            """)

# --- L√≥gica Principal ---
def main():
    if 'logged_in' not in st.session_state:
        st.session_state.logged_in = False
    if 'username' not in st.session_state:
        st.session_state.username = None

    if not st.session_state.logged_in:
        inicializar_banco()

    if not st.session_state.logged_in:
        tela_login()
    else:
        tipo_usuario = obter_tipo_usuario(st.session_state.username)
        st.sidebar.success(f"üëã **{st.session_state.username}**")
        st.sidebar.info(f"üé≠ {tipo_usuario}")
        
        # Notifica√ß√µes na sidebar
        if eh_admin(st.session_state.username):
            try:
                stats = contar_agendamentos_por_status()
                if stats[STATUS_PENDENTE] > 0:
                    st.sidebar.warning(f"‚ö†Ô∏è {stats[STATUS_PENDENTE]} pendente(s)")
            except:
                pass
        
        if st.sidebar.button("üö™ Sair", type="primary"):
            st.session_state.logged_in = False
            st.session_state.username = None
            st.success("‚úÖ Logout realizado!")
            st.rerun()
        
        if eh_admin(st.session_state.username):
            tela_admin()
        else:
            tela_professor()

if __name__ == "__main__":
    main()